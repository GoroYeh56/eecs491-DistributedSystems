package mapreduce

import (
	// "fmt"
	// "fmt"
	"strconv"
	"strings"
	"unicode"
)

// our simplified version of MapReduce does not supply a key to the
// Map function, as in Google's MapReduce paper; only a value,
// which is a portion of the input file's content
func WCMap(value string) []KeyValue {

	/*
		1. Split string into different words
		2. If words(IsLetter) => hash table record word counts
		3. Else: ignore
			return a list of KeyValue pair{key, value}
	*/

	myFunc := func(c rune) bool {
		return !unicode.IsLetter(c)
	}
	// a slice of strings
	sentences := strings.FieldsFunc(value, myFunc)

	local_map := []KeyValue{}
	for _, w := range sentences {
		key := w // a word
		local_map = append(local_map, KeyValue{key, "1"})
		// fmt.Println(KeyValue{key, "1"})
	}
	return local_map
}

// called once for each key generated by Map, with a list of that
// key's values. should return a single output value for that key.
func WCReduce(key string, values []string) string {
	// return a string: "number" of occurence for this key
	// fmt.Printf("%s: %d\n", key, len(values))
	return strconv.Itoa(len(values))

}
